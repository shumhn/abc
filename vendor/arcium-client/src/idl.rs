#![allow(clippy::too_many_arguments)]
// We need this because clippy otherwise complains about a function internally generated by anchor's
// declare_program!.
//! Generated modules from the idls of the programs we want to interact with.

use anchor_lang::{
    declare_program,
    prelude::AccountMeta,
    solana_program::instruction::Instruction,
};
use arcium::types::{
    ArxNodeConfig,
    CallbackAccount,
    CallbackInstruction,
    ComputationReference,
    NodeMetadata,
    NodeRef,
};
use std::hash::{Hash, Hasher};

declare_program!(arcium);
#[cfg(feature = "staking")]
declare_program!(arcium_staking);

impl Hash for ComputationReference {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.computation_offset.hash(state);
        self.priority_fee.hash(state);
    }
}

impl Eq for ComputationReference {}

impl PartialEq for ComputationReference {
    fn eq(&self, other: &Self) -> bool {
        self.computation_offset == other.computation_offset
            && self.priority_fee == other.priority_fee
    }
}

impl PartialEq for NodeMetadata {
    fn eq(&self, other: &Self) -> bool {
        self.location == other.location && self.ip == other.ip && self.peer_id == other.peer_id
    }
}

impl PartialEq for ArxNodeConfig {
    fn eq(&self, other: &Self) -> bool {
        self.max_cluster_memberships == other.max_cluster_memberships
            && self.authority == other.authority
            && self.callback_authority == other.callback_authority
    }
}

impl PartialEq for NodeRef {
    fn eq(&self, other: &Self) -> bool {
        self.offset == other.offset && self.current_total_rewards == other.current_total_rewards
    }
}

impl CallbackInstruction {
    pub fn to_instruction(&self, ix_data: &[u8]) -> Instruction {
        let mut data = Vec::with_capacity(self.discriminator.len() + ix_data.len());
        data.extend_from_slice(&self.discriminator);
        data.extend_from_slice(ix_data);
        Instruction {
            program_id: self.program_id,
            accounts: self.accounts.iter().map(|acc| acc.into()).collect(),
            data,
        }
    }
}

impl From<&CallbackAccount> for AccountMeta {
    fn from(acc: &CallbackAccount) -> Self {
        AccountMeta {
            pubkey: acc.pubkey,
            is_signer: false,
            is_writable: acc.is_writable,
        }
    }
}

// Although Epoch is the same in `arcium` and `arcium_staking`
// (which imports it from `arcium`) when it gets exported via the idl this information gets lost and
// rust thinks they're two different types. We add these two traits so that we can convert between
// them and don't have to constantly think about which Epoch is needed where.
#[cfg(feature = "staking")]
impl From<arcium_staking::types::Epoch> for arcium::types::Epoch {
    fn from(val: arcium_staking::types::Epoch) -> Self {
        arcium::types::Epoch(val.0)
    }
}

#[cfg(feature = "staking")]
impl From<arcium::types::Epoch> for arcium_staking::types::Epoch {
    fn from(val: arcium::types::Epoch) -> Self {
        arcium_staking::types::Epoch(val.0)
    }
}
